use crate::notifications::behavior::Protocol;
use crate::notifications::combine_upgrades::CombineUpgrades;
use crate::notifications::handshake::{
    HandshakeInbound, HandshakeInboundSubstream, HandshakeOutbound, HandshakeOutboundSubstream,
};
use crate::notifications::messages::{BlockAnnouncesHandshake, ProtocolRole};
use bytes::BytesMut;
use codec::Encode;
use futures::SinkExt;
use futures::channel::mpsc;
use futures::prelude::*;
use libp2p::PeerId;
use libp2p::core::ConnectedPoint;
use libp2p::swarm::handler::{ConnectionEvent, FullyNegotiatedInbound};
use libp2p::swarm::{
    ConnectionHandler, ConnectionHandlerEvent, Stream as NegotiatedSubstream, SubstreamProtocol,
};
use primitive_types::H256;
use std::collections::VecDeque;
use std::pin::Pin;
use std::task::{Context, Poll};
use std::{mem, vec};

/// Configuration for a notifications protocol.
pub(crate) struct ProtocolDetails {
    /// The name of the notification protocol.
    pub name: String,
    /// Handshake that is submitted upon connection.
    pub handshake: Vec<u8>,
    /// The state of the protocol.
    pub state: State,
}

pub struct Handler {
    protocols: Vec<ProtocolDetails>,

    /// Events that are pending to be processed by `poll()`.
    pending_events:
        VecDeque<ConnectionHandlerEvent<HandshakeOutbound, usize, NotificationsHandlerToBehavior>>,

    /// Whether we are the connection dialer or listener.
    endpoint: ConnectedPoint,
    /// Peer we are connected to.
    peer: PeerId,
}

/// Events generated from the network behavior to inform about the protocol connections.
#[derive(Debug, Clone)]
pub enum NotificationsHandlerFromBehavior {
    /// Open a new notification protocol.
    Open { i: usize },
    /// Close the notification protocol.
    Close { i: usize },
}

/// Events generated by this handler.
#[derive(Debug, Clone)]
pub enum NotificationsHandlerToBehavior {
    /// Response of [`NotificationsHandlerFromBehavior::Open`].
    ///
    /// Received handshake in expected format.
    HandshakeCompleted {
        i: usize,
        endpoint: ConnectedPoint,
        sender: mpsc::Sender<Vec<u8>>,
    },
    /// Response of [`NotificationsHandlerFromBehavior::Open`].
    ///
    /// Handshake cannot be established.
    HandshakeError {
        i: usize,
    },
    OpenDesiredByRemote {
        i: usize,
    },
    CloseDesired {
        i: usize,
    },
    /// Response of [`NotificationsHandlerFromBehavior::Close`].
    Close {
        i: usize,
    },
    /// Notification received by this protocol.
    Notification {
        i: usize,
        bytes: BytesMut,
    },
}

/// The state of a notification protocol.
///
/// ### Transitions
///
/// ```ignore
/// Closed -> OpenDesiredByRemote
///                 |
///                 |
///                 ----------------> announce behavior about protocol open
///
///                 |---------------  behavior ack
///                 |
///           OpenDesiredByRemote -> Opening -> Open
/// ```
#[allow(clippy::large_enum_variant)]
pub enum State {
    /// Protocol is closed.
    Closed {
        /// True if we should open the protocol.
        pending_opening: bool,
    },
    /// Initiated a new substream.
    OpenDesiredByRemote {
        /// Handle handshake.
        inbound_substream: HandshakeInboundSubstream<NegotiatedSubstream>,
        /// True if we should open the protocol.
        pending_opening: bool,
    },
    /// Opening the protocol by handshake negotiation.
    Opening {
        /// Set the first time. Contains a value when the handshake is in progress.
        inbound_substream: Option<HandshakeInboundSubstream<NegotiatedSubstream>>,
        /// Direction of substream.
        inbound: bool,
    },
    /// Protocol is opened, handshake has been negotiated.
    Open {
        recv: stream::Peekable<mpsc::Receiver<Vec<u8>>>,
        inbound_substream: Option<HandshakeInboundSubstream<NegotiatedSubstream>>,
        outbound_substream: Option<HandshakeOutboundSubstream<NegotiatedSubstream>>,
    },
}

impl Handler {
    pub fn new<Number, Hash>(
        peer: PeerId,
        endpoint: ConnectedPoint,
        protocols: Vec<Protocol<Hash>>,
    ) -> Self
    where
        Number: From<u32> + Encode,
        Hash: AsRef<[u8]> + Clone + Encode,
    {
        let protocols = protocols
            .into_iter()
            .map(|protocol| {
                let (protocol, handshake) = match protocol {
                    Protocol::BlockAnnounce { genesis_hash } => {
                        // This implementation does not fallback on the legacy supported protocols (ie `/dot/../1`).
                        // The genesis hash must be hex-encoded without the "0x" sufix.
                        let genesis_string = hex::encode(genesis_hash.clone());
                        let protocol = format!("/{genesis_string}/block-announces/1");
                        let hash = H256::from_slice(genesis_hash.as_ref());
                        let block_announces = BlockAnnouncesHandshake::from_genesis(hash);
                        (protocol, block_announces.encode())
                    }
                    Protocol::Protocol(name) => (name, vec![ProtocolRole::FullNode.encoded()]),
                };

                ProtocolDetails {
                    name: protocol.clone(),
                    handshake,
                    state: State::Closed {
                        pending_opening: false,
                    },
                }
            })
            .collect();

        Handler {
            peer,
            pending_events: VecDeque::with_capacity(16),
            endpoint,
            protocols,
        }
    }
}

impl ConnectionHandler for Handler {
    // Received and submitted events.
    type FromBehaviour = NotificationsHandlerFromBehavior;
    type ToBehaviour = NotificationsHandlerToBehavior;

    // Handle handshakes.
    type InboundProtocol = CombineUpgrades<HandshakeInbound>;
    type OutboundProtocol = HandshakeOutbound;

    type InboundOpenInfo = ();
    type OutboundOpenInfo = usize;

    fn listen_protocol(&self) -> SubstreamProtocol<Self::InboundProtocol, ()> {
        let protocol_upgrades: Vec<_> = self
            .protocols
            .iter()
            .map(|p| HandshakeInbound::new(p.name.clone()))
            .collect();
        let combine_upgrades = CombineUpgrades::from(protocol_upgrades);
        SubstreamProtocol::new(combine_upgrades, ())
    }

    fn connection_keep_alive(&self) -> bool {
        if self
            .protocols
            .iter()
            .any(|p| !matches!(p.state, State::Closed { .. }))
        {
            return true;
        }

        false
    }

    fn poll(
        &mut self,
        cx: &mut Context,
    ) -> Poll<
        ConnectionHandlerEvent<Self::OutboundProtocol, Self::OutboundOpenInfo, Self::ToBehaviour>,
    > {
        if let Some(ev) = self.pending_events.pop_front() {
            return Poll::Ready(ev);
        }

        for i in 0..self.protocols.len() {
            // Propagate user submitted message for the given protocol.
            if let State::Open {
                outbound_substream: Some(outbound_substream),
                recv,
                ..
            } = &mut self.protocols[i].state
            {
                #[allow(clippy::while_let_loop)]
                loop {
                    // Step 1. Check if we received a messages from the user.
                    // Step 2. Check if the peer substream is ready to receive the message.
                    // Step 3. Fetch the message from the user channel.
                    // Step 4. Send the message on the peer substream.

                    match Pin::new(&mut *recv).as_mut().poll_peek(cx) {
                        Poll::Ready(Some(..)) => {}
                        _ => break,
                    };

                    match outbound_substream.poll_ready_unpin(cx) {
                        Poll::Ready(_) => {}
                        Poll::Pending => break,
                    };

                    let message = match recv.poll_next_unpin(cx) {
                        Poll::Ready(Some(message)) => message,
                        Poll::Ready(None) | Poll::Pending => {
                            // Should never be reached, as per `poll_peek` above.
                            debug_assert!(false);
                            break;
                        }
                    };

                    log::trace!(
                        "Handler poll send message peer={:?} message={:?}",
                        self.peer,
                        message
                    );

                    // Flush all outbound streams below.
                    let _ = outbound_substream.start_send_unpin(message);
                }
            }
        }

        for i in 0..self.protocols.len() {
            // Flush outbound stream.
            if let State::Open {
                outbound_substream: outbound_substream @ Some(_),
                ..
            } = &mut self.protocols[i].state
            {
                match Sink::poll_flush(Pin::new(outbound_substream.as_mut().unwrap()), cx) {
                    Poll::Pending | Poll::Ready(Ok(())) => {}
                    Poll::Ready(Err(_)) => {
                        *outbound_substream = None;

                        return Poll::Ready(ConnectionHandlerEvent::NotifyBehaviour(
                            NotificationsHandlerToBehavior::CloseDesired { i },
                        ));
                    }
                }
            }
        }

        // Poll inbound stream.
        for i in 0..self.protocols.len() {
            match &mut self.protocols[i].state {
                State::Open {
                    inbound_substream: inbound_substream @ Some(_),
                    ..
                } => match Stream::poll_next(Pin::new(inbound_substream.as_mut().unwrap()), cx) {
                    Poll::Pending => {}
                    Poll::Ready(Some(Ok(bytes))) => {
                        let event = NotificationsHandlerToBehavior::Notification { i, bytes };
                        return Poll::Ready(ConnectionHandlerEvent::NotifyBehaviour(event));
                    }
                    Poll::Ready(None) | Poll::Ready(Some(Err(_))) => *inbound_substream = None,
                },

                State::OpenDesiredByRemote {
                    inbound_substream,
                    pending_opening,
                } => match HandshakeInboundSubstream::poll_process(Pin::new(inbound_substream), cx)
                {
                    Poll::Pending => {}
                    Poll::Ready(Ok(void)) => match void {},
                    Poll::Ready(Err(_)) => {
                        self.protocols[i].state = State::Closed {
                            pending_opening: *pending_opening,
                        };
                        return Poll::Ready(ConnectionHandlerEvent::NotifyBehaviour(
                            NotificationsHandlerToBehavior::CloseDesired { i },
                        ));
                    }
                },

                State::Opening {
                    inbound_substream: inbound_substream @ Some(_),
                    ..
                } => match HandshakeInboundSubstream::poll_process(
                    Pin::new(inbound_substream.as_mut().unwrap()),
                    cx,
                ) {
                    Poll::Pending => {}
                    Poll::Ready(Ok(void)) => match void {},
                    Poll::Ready(Err(_)) => *inbound_substream = None,
                },

                _ => (),
            }
        }

        Poll::Pending
    }

    fn on_behaviour_event(&mut self, message: NotificationsHandlerFromBehavior) {
        match message {
            NotificationsHandlerFromBehavior::Open { i } => {
                log::debug!("Handler from behavior Open peer={:?}", self.peer);

                let proto = &mut self.protocols[i];
                match &mut proto.state {
                    State::Closed { pending_opening } => {
                        if !*pending_opening {
                            let protocol = HandshakeOutbound {
                                name: proto.name.clone(),
                                handshake: self.protocols[i].handshake.clone(),
                            };

                            log::trace!(
                                "Handler from behavior Closed -> request new substream peer={:?}",
                                self.peer,
                            );

                            self.pending_events.push_back(
                                ConnectionHandlerEvent::OutboundSubstreamRequest {
                                    protocol: SubstreamProtocol::new(protocol, i),
                                },
                            )
                        }

                        log::trace!(
                            "Handler from behavior Closed -> Opening peer={:?}",
                            self.peer,
                        );

                        self.protocols[i].state = State::Opening {
                            inbound_substream: None,
                            inbound: false,
                        };
                    }
                    State::OpenDesiredByRemote {
                        inbound_substream,
                        pending_opening,
                    } => {
                        if !*pending_opening {
                            let protocol = HandshakeOutbound {
                                name: proto.name.clone(),
                                handshake: proto.handshake.clone(),
                            };

                            log::trace!(
                                "Handler from behavior OpenDesiredByRemote -> request new substream peer={:?}",
                                self.peer,
                            );

                            self.pending_events.push_back(
                                ConnectionHandlerEvent::OutboundSubstreamRequest {
                                    protocol: SubstreamProtocol::new(protocol, i),
                                },
                            )
                        }

                        log::trace!(
                            "Handler from behavior OpenDesiredByRemote setup handshake peer={:?}",
                            self.peer,
                        );

                        let handshake = proto.handshake.clone();
                        inbound_substream.set_handshake(handshake);

                        let inbound_substream = match mem::replace(
                            &mut proto.state,
                            State::Opening {
                                inbound_substream: None,
                                inbound: false,
                            },
                        ) {
                            State::OpenDesiredByRemote {
                                inbound_substream, ..
                            } => inbound_substream,
                            _ => unreachable!(),
                        };
                        proto.state = State::Opening {
                            inbound_substream: Some(inbound_substream),
                            inbound: true,
                        };
                    }
                    State::Opening { .. } | State::Open { .. } => {
                        log::trace!(
                            "Handler from behavior Opening|Open state mismatch peer={:?}",
                            self.peer,
                        );
                    }
                }
            }

            NotificationsHandlerFromBehavior::Close { i } => {
                log::debug!("Handler from behavior Close peer={:?}", self.peer,);

                let proto = &mut self.protocols[i];

                match proto.state {
                    State::Closed { .. } => {}
                    State::OpenDesiredByRemote {
                        pending_opening, ..
                    } => {
                        proto.state = State::Closed { pending_opening };
                    }
                    State::Opening { .. } => {
                        proto.state = State::Closed {
                            pending_opening: true,
                        };

                        log::trace!(
                            "Handler from behavior Close with handshake in progress peer={:?}",
                            self.peer,
                        );

                        self.pending_events
                            .push_back(ConnectionHandlerEvent::NotifyBehaviour(
                                NotificationsHandlerToBehavior::HandshakeError { i },
                            ));
                    }
                    State::Open { .. } => {
                        proto.state = State::Closed {
                            pending_opening: false,
                        };
                    }
                }

                self.pending_events
                    .push_back(ConnectionHandlerEvent::NotifyBehaviour(
                        NotificationsHandlerToBehavior::Close { i },
                    ));
            }
        }
    }

    fn on_connection_event(
        &mut self,
        event: ConnectionEvent<
            '_,
            Self::InboundProtocol,
            Self::OutboundProtocol,
            Self::InboundOpenInfo,
            Self::OutboundOpenInfo,
        >,
    ) {
        match event {
            ConnectionEvent::FullyNegotiatedInbound(FullyNegotiatedInbound {
                protocol, ..
            }) => {
                let (mut stream, i) = (protocol.data, protocol.index);

                log::debug!("Handler negotiated inbound peer={:?}", self.peer,);

                let proto = &mut self.protocols[i];
                match proto.state {
                    State::Closed { pending_opening } => {
                        log::trace!(
                            "Handler negotiated inbound Closed -> OpenDesiredByRemote peer={:?}",
                            self.peer,
                        );

                        self.pending_events
                            .push_back(ConnectionHandlerEvent::NotifyBehaviour(
                                NotificationsHandlerToBehavior::OpenDesiredByRemote { i },
                            ));

                        proto.state = State::OpenDesiredByRemote {
                            inbound_substream: stream.substream,
                            pending_opening,
                        };
                    }
                    State::OpenDesiredByRemote { .. } => {
                        log::trace!(
                            "Handler negotiated inbound OpenDesiredByRemote peer={:?}",
                            self.peer,
                        );
                    }
                    State::Opening {
                        ref mut inbound_substream,
                        ..
                    }
                    | State::Open {
                        ref mut inbound_substream,
                        ..
                    } => {
                        // Already handled.
                        if inbound_substream.is_some() {
                            log::trace!(
                                "Handler negotiated inbound handshake already handled peer={:?}",
                                self.peer,
                            );
                            return;
                        }

                        log::trace!(
                            "Handler negotiated inbound setup handshake peer={:?}",
                            self.peer,
                        );

                        let handshake_message = proto.handshake.clone();
                        stream.substream.set_handshake(handshake_message);
                        *inbound_substream = Some(stream.substream);
                    }
                }
            }
            ConnectionEvent::FullyNegotiatedOutbound(outbound) => {
                let (opened, i) = (outbound.protocol, outbound.info);

                log::debug!("Handler negotiated outbound peer={:?}", self.peer,);

                let proto = &mut self.protocols[i];
                match proto.state {
                    State::Closed {
                        ref mut pending_opening,
                    }
                    | State::OpenDesiredByRemote {
                        ref mut pending_opening,
                        ..
                    } => {
                        log::trace!(
                            "Handler negotiated outbound Closed|OpenDesiredByRemote peer={:?}",
                            self.peer,
                        );

                        *pending_opening = false;
                    }
                    State::Opening {
                        ref mut inbound_substream,
                        inbound,
                    } => {
                        log::trace!(
                            "Handler negotiated outbound Opening successful peer={:?}. Inbound: {inbound:?}",
                            self.peer,
                        );

                        let (send, recv) = mpsc::channel(1024);
                        proto.state = State::Open {
                            inbound_substream: inbound_substream.take(),
                            outbound_substream: Some(opened.substream),
                            recv: recv.peekable(),
                        };

                        self.pending_events
                            .push_back(ConnectionHandlerEvent::NotifyBehaviour(
                                NotificationsHandlerToBehavior::HandshakeCompleted {
                                    i,
                                    endpoint: self.endpoint.clone(),
                                    sender: send,
                                },
                            ));
                    }
                    State::Open { .. } => {
                        log::trace!(
                            "Handler negotiated outbound Open missmatch-state peer={:?}",
                            self.peer,
                        );
                    }
                }
            }
            ConnectionEvent::DialUpgradeError(err) => {
                log::debug!(
                    "Handler DialError peer={:?} error={:?}",
                    self.peer,
                    err.error,
                );

                let proto = &mut self.protocols[err.info];

                match proto.state {
                    State::Closed {
                        ref mut pending_opening,
                    }
                    | State::OpenDesiredByRemote {
                        ref mut pending_opening,
                        ..
                    } => {
                        log::trace!(
                            "Handler DialError Closed|OpenDesiredByRemote peer={:?}",
                            self.peer,
                        );

                        *pending_opening = false;
                    }
                    State::Opening { .. } => {
                        proto.state = State::Closed {
                            pending_opening: false,
                        };

                        log::trace!("Handler DialError Opening -> Closed peer={:?}", self.peer,);

                        self.pending_events
                            .push_back(ConnectionHandlerEvent::NotifyBehaviour(
                                NotificationsHandlerToBehavior::HandshakeError { i: err.info },
                            ));
                    }
                    State::Open { .. } => {}
                }
            }
            _ => {}
        }
    }
}
